---
title: "sna_hurricane"
author: "Alba Motes Rodrigo"
date: "2023-11-22"
output: html_document
---
#load packages and data
```{r}
#packages
library(igraph);library(dplyr);library(ggplot2);library(foreach); library(doParallel); library(stringr); library(tidyverse);library(magrittr); library(fs); library(lme4)

#data
load("/Users/alba/Desktop/Postdoc_UNIL/Hurricane_project/BisonFittedNetworks.RData")
load("/Users/alba/Desktop/Postdoc_UNIL/Hurricane_project/proximity_data-2.RData")
```
Remember that all networks are fully connected so modularity and clustering cannot be calculated as they are based on edge densities.

```{r}
#create storage object for densities
obs_dens<-matrix(NA,ncol=1, nrow = length(unique(edgelist.all$groupyear)))
row.names(obs_dens)<-unique(edgelist.all$groupyear)
colnames(obs_dens)<-c("density")

#create groupyear combination variable
edgelist.all$groupyear<-paste(edgelist.all$group, edgelist.all$year, sep="")
#calculate observed network densities
for (g in unique(edgelist.all$groupyear)){
  z<-subset(edgelist.all, groupyear==g, select = c("ID1", "ID2", "count"))
  z<-z[z$count!= 0,]
  w<-graph_from_data_frame(z[,c(1,2)], directed = F, vertices = NULL)
  E(w)$weight <- z[,3]
  obs_dens[g,1]<-edge_density(w)}

# Setting the threshold at a given density and filtering edges with very small observation prob
posterior.filtered<-vector(mode = "list", length=length(unique(edgelist.all$groupyear)))
names(posterior.filtered)<-unique(edgelist.all$groupyear)

for(s in unique(edgelist.all$groupyear)){#for each groupyear combination

DesiredDensity <- obs_dens[s,1]#extract observed density
#find the threshold needed to assign 0s
FindThreshold <- function(Connections){
  
  Ranks <- rank(Connections)/max(rank(Connections)) # Identifies the numerical order of the values
  
  Connections[Ranks < (1-DesiredDensity)] <- 0 # Assigns the bottom 80% as 0 (according to the density desired)
  
  Connections %>% return # Returns
  
}
#set to 0 all edges with a value below threshold
posterior.filtered[[s]]<-posterior.el[[s]][,3:1002] %>% 
  map(FindThreshold) %>%  # Does this across all draws in the data frame
  bind_cols() %>% 
  bind_cols(posterior.el[[s]][,1:2], .) }
```

```{r}
#create storage object with one value per network
modul_networks<-matrix(, ncol = length(names(posterior.el)), nrow = 1000)
colnames(modul_networks)<-names(posterior.el)

dense_networks<-matrix(, ncol = length(names(posterior.el)), nrow = 1000)
colnames(dense_networks)<-names(posterior.el)

trans_networks<-matrix(, ncol = length(names(posterior.el)), nrow = 1000)
colnames(trans_networks)<-names(posterior.el)

#calculate metrics for each network
for (g in 1:length(names(posterior.filtered))){
  for (d in 3:1002){
    #create each graph
    x<-graph_from_data_frame(posterior.filtered[[g]][,c(1,2)], directed = F, vertices = NULL)
    E(x)$weight <- posterior.filtered[[g]][,d]
    #calculate modularity
    #Greedy optimization for community assignment
    cfg<-cluster_fast_greedy(x, modularity = T, membership = T, weights = posterior.filtered[[g]][,d])
    modul_networks[d-2,g] <-modularity(cfg)
    #substract 0 edges
    y<-delete.edges(x,E(x)[E(x)$weight == 0])
    dense_networks[d-2,g]<- edge_density(y)
    trans_networks[d-2,g]<-transitivity(y, type="global")
  }
}

```

#Data set preparation for model
```{r}
preyears<-as.character(seq(2013,2017))
#prepare modularity data for model
modul_networkst<- modul_networks %>% t()%>% as.data.frame() %>% rownames_to_column()
colnames(modul_networkst)[2:1001]<-paste("draw", seq(1:1000), sep=".")
colnames(modul_networkst)[1]<-"groupyear"
modul_networkst <- modul_networkst %>% 
  pivot_longer(
    cols = 2:1001, 
    names_to = "draw",
    values_to = "modularity"
)
modul_networkst$year<-sub('.*(\\d{4}).*', '\\1', modul_networkst$groupyear)
modul_networkst$prepost<- ifelse(modul_networkst$year %in% preyears, "pre", "post")
modul_networkst$group<-gsub("[^a-zA-Z]", "", modul_networkst$groupyear)

#prepare transitivity data for model
trans_networkst<- trans_networks %>% t()%>% as.data.frame() %>% rownames_to_column()
colnames(trans_networkst)[2:1001]<-paste("draw", seq(1:1000), sep=".")
colnames(trans_networkst)[1]<-"groupyear"
trans_networkst <- trans_networkst %>% 
  pivot_longer(
    cols = 2:1001, 
    names_to = "draw",
    values_to = "transitivity"
)
trans_networkst$year<-sub('.*(\\d{4}).*', '\\1', trans_networkst$groupyear)
trans_networkst$prepost<- ifelse(trans_networkst$year %in% preyears, "pre", "post")
trans_networkst$group<-gsub("[^a-zA-Z]", "", trans_networkst$groupyear)

#model modularity before after
hist(modul_networkst$modularity)#quite normal
model_modularity<-lmer(modularity ~ prepost + (1|group), data = modul_networkst)
drop1(model_modularity, test="Chisq")
summary(model_modularity)

#model transitivity before after
hist(log(trans_networkst$transitivity))#quite normal
model_transitivity<-lmer(log(transitivity) ~ prepost + (1|group), data = trans_networkst)
drop1(model_transitivity, test="Chisq")
summary(model_transitivity)["Estimate"]
fixef(model_transitivity)["prepostpre"]
```

#Models fitted to each network replicate separately
```{r}
#Modularity
#object to store pre-post estimates
prepost_estimates_m<-matrix(NA,ncol=1000, nrow=1)
colnames(prepost_estimates_m)<-unique(modul_networkst$draw)
for (d in unique(modul_networkst$draw)){
  model_modularity<-lmer(modularity ~ prepost + (1|group), data = modul_networkst[modul_networkst$draw==d,])
  prepost_estimates_m[1, d]<-fixef(model_modularity)["prepostpre"]
}

hist(prepost_estimates_m)

#Transitivity
#object to store pre-post estimates
prepost_estimates<-matrix(NA,ncol=1000, nrow=1)
colnames(prepost_estimates)<-unique(trans_networkst$draw)
for (d in unique(trans_networkst$draw)){
  model_transitivity<-lmer(transitivity ~ prepost + (1|group), data = trans_networkst[trans_networkst$draw==d,])
  prepost_estimates[1, d]<-fixef(model_transitivity)["prepostpre"]
}

hist(prepost_estimates)
```

Plots of modularity and transitivity 
```{r}
#calculate means
df_mean_trans<-trans_networkst %>% group_by(year, group) %>% summarise(mean_trans=mean(transitivity))
df_mean_mod<-modul_networkst %>% group_by(year, group) %>% summarise(mean_mod=mean(modularity))

#plots modularity and transitivity
ggplot(trans_networkst, aes(x=year,y= transitivity, colour = group, group = group)) + 
  geom_line(linewidth = 1) + theme_bw() + ylab("transitivity") +
  geom_point(data=df_mean_trans,  mapping=aes(x = year, y = mean_trans), col="black")

ggplot(modul_networkst, aes(x=year,y= modularity, colour = group, group = group)) + 
  geom_line(linewidth = 1) + theme_bw() + ylab("modularity") +
  geom_point(data=df_mean_mod,  mapping=aes(x = year, y = mean_mod), col="black")

```



```{r}
rm(posterior.el, edgelist.all, w,x,y,z, cfg, posterior.filtered)
save.image(file='/Users/alba/Desktop/Postdoc_UNIL/Hurricane_project/network_metrics_pre_post.RData')
```

#random network generation
```{r}
posterior.random<-vector(mode = "list", length=length(names(posterior.el)))
names(posterior.random)<-names(posterior.el)
for(s in names(posterior.el)){
  x<-sample(posterior.el[[s]][,1],length(posterior.el[[s]][,1]))
  y<-sample(posterior.el[[s]][,2],length(posterior.el[[s]][,2]))
  z<-posterior.el[[s]][,3:1002]
  posterior.random[[s]]<-bind_cols(node_1=x,node_2=y,z)}

saveRDS(posterior.random, file = '/Users/alba/Desktop/Postdoc_UNIL/Hurricane_project/random_networks.RDS')
````

