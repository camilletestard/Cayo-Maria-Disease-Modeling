load("~/Library/Mobile Documents/com~apple~CloudDocs/Cayo-Maria-Disease-Modeling/Data/R.Data/proximity_data.RData")
load("/Data/R.Data/proximity_data.RData")
#read data
# load("~/Library/Mobile Documents/com~apple~CloudDocs/Cayo-Maria-Disease-Modeling/Data/R.Data/proximity_data.RData")
load("Data/R.Data/proximity_data.RData")
#read data
# load("~/Library/Mobile Documents/com~apple~CloudDocs/Cayo-Maria-Disease-Modeling/Data/R.Data/proximity_data.RData")
load("Data/R.Data/proximity_data.RData")
#create weight variable. Proportion of scans observed in proximity
edgelist.all$weight<- edgelist.all$count/edgelist.all$total_samples
table(edgelist.all$group, edgelist.all$year)#S group is only observed one year and both KK and F are only observed one year after the huricane.
#separate data by group and year
V.data<-subset(edgelist.all, group=="V")
F.data<-subset(edgelist.all, group=="F")
KK.data<-subset(edgelist.all, group=="KK")
#number of individuals observed per year
V.data%>%group_by(year)%>%summarise(N=length(unique(unlist(ID1,ID2))))
#create different data frames for each year and combine into one list V.data.list
yearsV<-unique(V.data$year)
V.data.list<-list()
for (i in 1:length(yearsV)){
V.data.list[[i]]<-subset(V.data, year==yearsV[i])
}
names(V.data.list)<-yearsV
for (i in 1:length(V.data.list)){
V.data.list[[i]]$weight<-replace(V.data.list[[i]]$weight, V.data.list[[i]]$weight == 0, 0.0001)
}
mins<-rep(NA, 6)
for (i in 1:length(V.data.list)){
mins[i]<-min(V.data.list[[i]]$weight, na.rm = T)
}
mins
list_df=V.data.list
reps=5#number of times the simulation should be repeated
#at each simulation time step, two individuals will interact according to their probability of proxomity (edge weight). In each time step, all possible dyads are considered.
sims=1000#number of time steps/times each dyad should be allowed to potentially interact/scans
simu_res = list()#storing object for simulation results
props_res=data.frame(matrix(NA, nrow = sims, ncol = reps))
props_res_list= list()
list_names=yearsV
pinfs=c(0.01, 0.1, 0.2)
simu_res_pinf<-foreach(d=1:length(list_df))%:% foreach(pinf=pinfs)%dopar%{
#for each year...
df <- list_df[[d]]
#calculate group size
N=length(unique(unlist(df$ID1, df$ID2)))
#create adjancecy matrix
mygraph <- graph.data.frame(df)
my_mat<-get.adjacency(mygraph, sparse = FALSE, attr='weight')
#next line optional but ensures lower tri is NAs
my_mat[lower.tri(my_mat)] <- NA
#empty vectors for simulation results
value100 <- rep(NA, reps)
value90 <- rep(NA, reps)
value50 <- rep(NA, reps)
value60 <- rep(NA, reps)
value70 <- rep(NA, reps)
value80 <- rep(NA, reps)
maxprop <- rep(NA, reps)
props <- rep(NA, sims)
for (r in 1:reps){
#create vector to store the health status of each individual at each simulation step (sim)
health=rep(0, N)
#infect a random individual, change its status to infected in health vector
health[floor(runif(1, min=1, max=N+1))]=1
for(s in 1:sims){
#create new vector where infected individuals ID are stored after each iteraction over the matrix
health_update=c()
#iterate over upper triangle matrix
for(i in 1:(N-1)){
for(j in (i+1):N){
#if one of the two individuals considered is infected..
if(sum(health[i],health[j])==1){
#evaluate whether they interact according to edge weight
if(runif(n=1)<my_mat[i,j]){
#if they interact, evaluate whether it gets infected. If it does...
if(runif(n=1)<pinf){
#update its status to infected in the updates' vector
health_update <- append(health_update,c(i,j))
}
}
}
}
}
#change the status of the newly infected individuals in the health status vector
health_unique<- unique(health_update)
for (h in health_unique){
health[h]=1
}
#calculate proportion of infected individuals in each simulation step (sims)
props[s]<- sum(health)/length(health)
}
#write down at which simulation step different thresholds of proportions of individuals infected were reached for each repetition of the simulation (reps)
value100[r] <- which(props == 1)[1]
value90[r] <- which(props >= 0.9)[1]
value80[r] <- which(props >= 0.8)[1]
value70[r] <- which(props >= 0.7)[1]
value60[r] <- which(props >= 0.6)[1]
value50[r] <- which(props >= 0.5)[1]
maxprop[r] <- max(props)
#store proportion of infected individuals at each simulation step for each repetition of the simulation (reps)
props_res[, r]<-props
}
#store simulation steps at which thresholds were reached in each repetition of the simulation into list
simu_res[[d]]<- list(data.frame("time_to_100"=value100,
"time_to_90"=value90,
"time_to_50"=value50,
"time_to_80"=value80,
"time_to_70"=value70,
"time_to_60"=value60,
"max_infected"=maxprop), props_res)
}
#name data frames in list with year names
names(simu_res_pinf)<-list_names
for (i in 1:6){
names(simu_res_pinf[[i]]) <- pinfs
}
simu_res=list()
sims=1000
simu_res_ids<-foreach(d=1:length(list_df))%:% foreach(pinf=pinfs)%dopar%{
#for each year...
df <- list_df[[d]]
#calculate group size
N=length(unique(unlist(df$ID1, df$ID2)))
#create adjancecy matrix
mygraph <- graph.data.frame(df)
my_mat<-get.adjacency(mygraph, sparse = FALSE, attr='weight')
#next line optional but ensures lower tri is NAs
my_mat[lower.tri(my_mat)] <- NA
#empty vectors for simulation results
#create vector to store the health status of each individual at each simulation step (sim)
inf_ids_df=data.frame(matrix(NA, nrow = N, ncol = sims))
health=rep(0, N)
#infect a random individual, change its status to infected in health vector
health[floor(runif(1, min=1, max=N+1))]=1
for(s in 1:sims){
#create new vector where infected individuals ID are stored after each iteraction over the matrix
health_update=c()
#iterate over upper triangle matrix
for(i in 1:(N-1)){
for(j in (i+1):N){
#if one of the two individuals considered is infected..
if(sum(health[i],health[j])==1){
#evaluate whether they interact according to edge weight
if(runif(n=1)<my_mat[i,j]){
#if they interact, evaluate whether it gets infected. If it does...
if(runif(n=1)<pinfs){
#update its status to infected in the updates' vector
health_update <- append(health_update,c(i,j))
}
}
}
}
}
#change the status of the newly infected individuals in the health status vector
health_unique<- unique(health_update)
for (h in health_unique){
health[h]=1
}
inf_ids_df[, s]<-health
}
#store simulation steps at which thresholds were reached in each repetition of the simulation into list
#inf_ids_df$ids<- colnames(my_mat)
simu_res[d]<- inf_ids_df
}
#name data frames in list with year names
names(simu_res_ids)<-list_names
simu_res_ids[['2015']]
#Get_ProxData.R
#This script generates
library(stringr)
library(igraph)
library(lubridate)
library(hms)
library(data.table)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
#Load functions
setwd("~/Documents/GitHub/Cayo-Maria-Disease-Modeling/")
source("Functions/functions_GlobalNetworkMetrics.R")
group = c("F","V","KK","V","F","F","KK","V","V","KK","S","V","F","V")
years = c(2015,2015,2015,
2016,2016,2017,2017,2017,
2018, 2018,2019, 2019,2021,2021)
groupyears = c("F2015","V2015","KK2015",
"V2016","F2016","F2017",
"KK2017","V2017","V2018","KK2018",
"S2019","V2019","F2021","V2021")
gy=12#16
edgelist.all = data.frame()
savePath = '~/Documents/GitHub/Cayo-Maria-Disease-Modeling/Data/R.Data/'
for (gy in 1:length(groupyears)){ #for all group & years
print(paste("%%%%%%%%%%%%%%%%%% ",groupyears[gy], "%%%%%%%%%%%%%%%%%%"))
if (years[gy]==2018) {
#Load data
setwd('~/Documents/GitHub/Cayo-Maria-Disease-Modeling/Data/Data All Cleaned/BehavioralDataFiles')
scans2018= read.csv(paste("Group",groupyears[gy],"_scansamples_FULL_CLEANED.txt", sep = ""))
meta_data = read.csv(paste("Group",groupyears[gy],"_GroupByYear.txt", sep = "")) #load meta data
#Initialize SocialCaiptalData
SocialCapitalData= meta_data[,c("id","sex","age","ordinal.rank","percofsex.dominanted","hrs.focalfollowed","focalcutoff_met")]
SocialCapitalData$group = group[gy]
SocialCapitalData$year = years[gy]
##Format data##
scans2018$date <- lubridate::mdy(as.character(scans2018$date))
scans2018$year <- lubridate::year(scans2018$date)
scans2018$Q    <- lubridate::quarter(scans2018$date)
scans2018$date <- as.character(scans2018$date) #re-format to character after finding year and quarter
#Add unique scan identifier
scans2018$observation.name = as.factor(paste(scans2018$date, scans2018$scan.num,sep="."))
#Add hurricane info
scans2018$isPost = 1
#Format time and create timeBlock column
#IMPORTANT: MAKE SURE TIME COLUMNS ARE FORMATTED IN EXCEL IN FORMAT "13:55:00"
scans2018$start.time = as_hms(as.character(scans2018$start.time))
scans2018$stop.time = as_hms(as.character(scans2018$stop.time))
scans2018$timeBlock = NA
scans2018$timeBlock[which(scans2018$start.time <= as_hms("11:00:00"))] = "AM";
scans2018$timeBlock[which(scans2018$start.time > as_hms("11:00:00"))] = "PM";
#Format XEX names
unique(scans2018$subject.ID) #check spelling of subject id
scans2018$subject.ID=sub("'","",as.character(scans2018$subject.ID)) #Replace 'XEX byXEX names if needed
scans2018$subject.ID=str_trim(scans2018$subject.ID,side="both") #Remove blanks
unique(scans2018$prox.adult.IDs)
scans2018$prox.adult.IDs=sub("'","",as.character(scans2018$prox.adult.IDs))
#Clean up: rename and delete unused columns
scans2018[,c("stop.time","observer.initials","cayo.map.code","nearest.adult.neighbour.ID","distance.nearest.neighbour","start.time")]=NULL
names(scans2018)[3]="scan.number"; names(scans2018)[4]="focalID"; names(scans2018)[5]="focal.activity"; names(scans2018)[7]="in.proximity"
#create column with equivalent activity to pre-hurricane
scans2018[] = lapply(scans2018,str_trim)
scans2018$focal.activity.isPost = as.character(scans2018$focal.activity) #preserve post-hurricane activity code
#re-code activity to pre-hurricane for comparison
scans2018$focal.activity = as.character(scans2018$focal.activity)
scans2018$focal.activity[unique(c(which(scans2018$focal.activity=='G'),which(scans2018$focal.activity=='E'),which(scans2018$focal.activity=='E,P'),which(scans2018$focal.activity=='G,E')))]="social"
scans2018$focal.activity[unique(c(which(scans2018$focal.activity=='R'),which(scans2018$focal.activity=='P')))]="rest"
scans2018$focal.activity[unique(c(which(scans2018$focal.activity=='AG'),which(scans2018$focal.activity=='AR')))]="aggression"
scans2018$focal.activity[unique(c(which(scans2018$focal.activity=='SR'),which(scans2018$focal.activity=='SG')))]="submit"
scans2018$focal.activity[grep('T',scans2018$focal.activity)]="travel"
scans2018$focal.activity[grep('F',scans2018$focal.activity)]="feed"
scans2018$focal.activity[grep('D',scans2018$focal.activity)]="drink"
scans2018$focal.activity[grep('SD',scans2018$focal.activity)]="sdb"
scans2018$focal.activity[grep('N/A',scans2018$focal.activity)]="UNK"
#unique(scans2018$focal.activity) #Check correct activity categories
#Format in.proximity, count number of prox partners
scans2018$partner.ID = as.character(scans2018$partner.ID); scans2018$partner.ID[which(scans2018$partner.ID=="N/A")]=NA
scans2018$in.proximity = as.character(scans2018$in.proximity); scans2018$in.proximity[which(scans2018$in.proximity=="N/A")]=NA
scans2018$num.prox = str_count(as.character(scans2018$in.proximity),",")+1
scans2018$num.prox[is.na(scans2018$num.prox)]=0
#Add social information
scans2018$isProx=1; scans2018$isProx[which(scans2018$num.prox==0)]=0
scans2018$isSocial=0; scans2018$isSocial[which(scans2018$focal.activity=="social")]=1
scans2018$isSocialGive = 0; scans2018$isSocialGive[which(scans2018$focal.activity.isPost=="G")]=1
scans2018$isSocialGet = 0; scans2018$isSocialGet[which(scans2018$focal.activity.isPost=="E")]=1
scans2018$isAgg=0; scans2018$isAgg[which(scans2018$focal.activity=="aggression" | scans2018$focal.activity=="submit")]=1
#Order columns
col_order <- c("date","observation.name","focalID","group","year","scan.number","focal.activity","focal.activity.isPost","partner.ID","in.proximity","num.prox","isProx","isSocial","isSocialGive", "isSocialGet","isAgg", "Q","isPost","timeBlock")
scans2018 <- scans2018[, col_order]
prox_data =  scans2018[,c("focalID","in.proximity")]
}else{ #if not 2018 (i.e. regular focal data)
############################################################################
#Load data
setwd('~/Documents/GitHub/Cayo-Maria-Disease-Modeling/Data/Data All Cleaned/BehavioralDataFiles')
prox_data = read.csv(paste("Group",groupyears[gy],"_ProximityGroups.txt", sep = ""))
meta_data = read.csv(paste("Group",groupyears[gy],"_GroupByYear.txt", sep = "")) #load meta data
#cleaned_data = read.csv(paste("Group",groupyears[gy],"_CleanedData.txt", sep = ""))
#Set NA focal activity in scans to "Rest"
prox_data$focal.activity[is.na(prox_data$focal.activity)]="rest"
if (groupyears[gy]=="HH2016"){
#Add HH dominance for subadults.
hh.dominance <- read.csv("HH_Dominance.csv");names(hh.dominance)[1]="id"
hh.dominance$id = as.character(hh.dominance$id)
hh.dominance$id[hh.dominance$id=="2.00E+09"]="2E9"
hh.dominance$id[hh.dominance$id=="2.00E+08"]="2E8"
hh.dominance$id[hh.dominance$id=="7.00E+00"]="7E0"
hh.dominance$id[hh.dominance$id=="7.00E+03"]="7E3"
hh.dominance$id[hh.dominance$id=="8.00E+02"]="8E2"
meta_data[,c("ordinal.rank","percofsex.dominanted")]=hh.dominance[match(meta_data$id, hh.dominance$id),c("ordinal.rank","percofsex.domianted")]
}
if (groupyears[gy]=="KK2017"){
#Add HH dominance for juveniles.
kk.dominance <- read.csv("KK_dominance_withSubadults.csv");names(kk.dominance)[1]="id"
meta_data[,c("ordinal.rank","percofsex.dominanted")]=kk.dominance[match(meta_data$id, kk.dominance$id),c("ordinal.rank","percofsex.domianted")]
}
if (groupyears[gy] == "V2019"){ #quick fix for now
prox_idx = !is.na(prox_data$partners.activity..sequential.) #find indices where there are individuals in proximity
#add focal monkey in proximity column
prox_data$in.proximity[prox_idx]= paste(prox_data$focal.monkey[prox_idx],
prox_data$in.proximity[prox_idx],sep=",")
}
} #end of year clause (2018 vs. other)
#Format data with aggregate format
# Output the Master Edgelist of all possible pairs given the unique IDs.
unqIDs = meta_data$id#[meta_data$focalcutoff_met=="Y"]
edgelist = calcMasterEL(unqIDs);
df_obs_agg  = calcEdgeList(prox_data, edgelist); ##IMPORTANT NOTE: the structure of the proximity data is different for
#2018 relative to other years (the focal ID is not counted in proximity for 2018 but it is for other years)
#This is not a problem because the focal ID column name is not the same so the function works properly as is.
names(df_obs_agg)=c("ID1", "ID2", "dyad_id","count")
#Get observation effort for each dyad
if (years[gy]==2018){numscans = as.data.frame(table(prox_data$focalID))}else{ numscans = as.data.frame(table(prox_data$focal.monkey))}
df_obs_agg$ID1_obseff_duration = meta_data$hrs.focalfollowed[match(df_obs_agg$ID1, meta_data$id)]
df_obs_agg$ID1_obseff_samples = numscans$Freq[match(df_obs_agg$ID1, numscans$Var1)]
df_obs_agg$ID2_obseff_duration = meta_data$hrs.focalfollowed[match(df_obs_agg$ID2, meta_data$id)]
df_obs_agg$ID2_obseff_samples = numscans$Freq[match(df_obs_agg$ID2, numscans$Var1)]
df_obs_agg$total_obs_time = df_obs_agg$ID1_obseff_duration  + df_obs_agg$ID2_obseff_duration
df_obs_agg$total_samples = df_obs_agg$ID1_obseff_samples + df_obs_agg$ID2_obseff_samples
## Add id qualifiers
#sex
df_obs_agg$ID1_sex = meta_data$sex[match(df_obs_agg$ID1, meta_data$id)]
df_obs_agg$ID2_sex = meta_data$sex[match(df_obs_agg$ID2, meta_data$id)]
#rank
df_obs_agg$ID1_rank = meta_data$ordinal.rank[match(df_obs_agg$ID1, meta_data$id)]
df_obs_agg$ID2_rank = meta_data$ordinal.rank[match(df_obs_agg$ID2, meta_data$id)]
#age
df_obs_agg$ID1_age = meta_data$age[match(df_obs_agg$ID1, meta_data$id)]
df_obs_agg$ID2_age = meta_data$age[match(df_obs_agg$ID2, meta_data$id)]
#group, year, Hurricane status
df_obs_agg$group = group[gy]; df_obs_agg$year = years[gy];
if(years[gy]>2017){df_obs_agg$isPost = "post"}else{df_obs_agg$isPost = "pre"}
head(df_obs_agg)
###################################################################
# Merge and save data
edgelist.all = rbind(edgelist.all, df_obs_agg)
}
View(edgelist.all)
df = edgelist.all[edgelist.all$group=="V" & edgelist.all$year=="2019"]
df = edgelist.all[edgelist.all$group=="V" & edgelist.all$year=="2019",]
View(df)
df = edgelist.all[edgelist.all$group=="V" & edgelist.all$year=="2019",]
hist(df$count)
df = edgelist.all[edgelist.all$group=="V" & edgelist.all$year=="2018",]
hist(df$count)
df = edgelist.all[edgelist.all$group=="V" & edgelist.all$year=="2021",]
hist(df$count)
length(which(df$count==0))
df = edgelist.all[edgelist.all$group=="V" & edgelist.all$year=="2018",]
length(which(df$count==0))
df = edgelist.all[edgelist.all$group=="V" & edgelist.all$year=="2019",]
length(which(df$count==0))
length(which(df$count!=0))/nrow(df)
df = edgelist.all[edgelist.all$group=="V" & edgelist.all$year=="2015",]
length(which(df$count!=0))/nrow(df)
#Get_ProxData.R
#This script generates
library(stringr)
library(igraph)
library(lubridate)
library(hms)
library(data.table)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
#Load functions
setwd("~/Documents/GitHub/Cayo-Maria-Disease-Modeling/")
source("Functions/functions_GlobalNetworkMetrics.R")
group = c("F","V","KK","V","F","F","KK","V","V","KK","S","V","F","V")
years = c(2015,2015,2015,
2016,2016,2017,2017,2017,
2018, 2018,2019, 2019,2021,2021)
groupyears = c("F2015","V2015","KK2015",
"V2016","F2016","F2017",
"KK2017","V2017","V2018","KK2018",
"S2019","V2019","F2021","V2021")
gy=12#16
edgelist.all = data.frame()
savePath = '~/Documents/GitHub/Cayo-Maria-Disease-Modeling/Data/R.Data/'
for (gy in 1:length(groupyears)){ #for all group & years
print(paste("%%%%%%%%%%%%%%%%%% ",groupyears[gy], "%%%%%%%%%%%%%%%%%%"))
if (years[gy]==2018) {
#Load data
setwd('~/Documents/GitHub/Cayo-Maria-Disease-Modeling/Data/Data All Cleaned/BehavioralDataFiles')
scans2018= read.csv(paste("Group",groupyears[gy],"_scansamples_FULL_CLEANED.txt", sep = ""))
meta_data = read.csv(paste("Group",groupyears[gy],"_GroupByYear.txt", sep = "")) #load meta data
#Initialize SocialCaiptalData
SocialCapitalData= meta_data[,c("id","sex","age","ordinal.rank","percofsex.dominanted","hrs.focalfollowed","focalcutoff_met")]
SocialCapitalData$group = group[gy]
SocialCapitalData$year = years[gy]
##Format data##
scans2018$date <- lubridate::mdy(as.character(scans2018$date))
scans2018$year <- lubridate::year(scans2018$date)
scans2018$Q    <- lubridate::quarter(scans2018$date)
scans2018$date <- as.character(scans2018$date) #re-format to character after finding year and quarter
#Add unique scan identifier
scans2018$observation.name = as.factor(paste(scans2018$date, scans2018$scan.num,sep="."))
#Add hurricane info
scans2018$isPost = 1
#Format time and create timeBlock column
#IMPORTANT: MAKE SURE TIME COLUMNS ARE FORMATTED IN EXCEL IN FORMAT "13:55:00"
scans2018$start.time = as_hms(as.character(scans2018$start.time))
scans2018$stop.time = as_hms(as.character(scans2018$stop.time))
scans2018$timeBlock = NA
scans2018$timeBlock[which(scans2018$start.time <= as_hms("11:00:00"))] = "AM";
scans2018$timeBlock[which(scans2018$start.time > as_hms("11:00:00"))] = "PM";
#Format XEX names
unique(scans2018$subject.ID) #check spelling of subject id
scans2018$subject.ID=sub("'","",as.character(scans2018$subject.ID)) #Replace 'XEX byXEX names if needed
scans2018$subject.ID=str_trim(scans2018$subject.ID,side="both") #Remove blanks
unique(scans2018$prox.adult.IDs)
scans2018$prox.adult.IDs=sub("'","",as.character(scans2018$prox.adult.IDs))
#Clean up: rename and delete unused columns
scans2018[,c("stop.time","observer.initials","cayo.map.code","nearest.adult.neighbour.ID","distance.nearest.neighbour","start.time")]=NULL
names(scans2018)[3]="scan.number"; names(scans2018)[4]="focalID"; names(scans2018)[5]="focal.activity"; names(scans2018)[7]="in.proximity"
#create column with equivalent activity to pre-hurricane
scans2018[] = lapply(scans2018,str_trim)
scans2018$focal.activity.isPost = as.character(scans2018$focal.activity) #preserve post-hurricane activity code
#re-code activity to pre-hurricane for comparison
scans2018$focal.activity = as.character(scans2018$focal.activity)
scans2018$focal.activity[unique(c(which(scans2018$focal.activity=='G'),which(scans2018$focal.activity=='E'),which(scans2018$focal.activity=='E,P'),which(scans2018$focal.activity=='G,E')))]="social"
scans2018$focal.activity[unique(c(which(scans2018$focal.activity=='R'),which(scans2018$focal.activity=='P')))]="rest"
scans2018$focal.activity[unique(c(which(scans2018$focal.activity=='AG'),which(scans2018$focal.activity=='AR')))]="aggression"
scans2018$focal.activity[unique(c(which(scans2018$focal.activity=='SR'),which(scans2018$focal.activity=='SG')))]="submit"
scans2018$focal.activity[grep('T',scans2018$focal.activity)]="travel"
scans2018$focal.activity[grep('F',scans2018$focal.activity)]="feed"
scans2018$focal.activity[grep('D',scans2018$focal.activity)]="drink"
scans2018$focal.activity[grep('SD',scans2018$focal.activity)]="sdb"
scans2018$focal.activity[grep('N/A',scans2018$focal.activity)]="UNK"
#unique(scans2018$focal.activity) #Check correct activity categories
#Format in.proximity, count number of prox partners
scans2018$partner.ID = as.character(scans2018$partner.ID); scans2018$partner.ID[which(scans2018$partner.ID=="N/A")]=NA
scans2018$in.proximity = as.character(scans2018$in.proximity); scans2018$in.proximity[which(scans2018$in.proximity=="N/A")]=NA
scans2018$num.prox = str_count(as.character(scans2018$in.proximity),",")+1
scans2018$num.prox[is.na(scans2018$num.prox)]=0
#Add social information
scans2018$isProx=1; scans2018$isProx[which(scans2018$num.prox==0)]=0
scans2018$isSocial=0; scans2018$isSocial[which(scans2018$focal.activity=="social")]=1
scans2018$isSocialGive = 0; scans2018$isSocialGive[which(scans2018$focal.activity.isPost=="G")]=1
scans2018$isSocialGet = 0; scans2018$isSocialGet[which(scans2018$focal.activity.isPost=="E")]=1
scans2018$isAgg=0; scans2018$isAgg[which(scans2018$focal.activity=="aggression" | scans2018$focal.activity=="submit")]=1
#Order columns
col_order <- c("date","observation.name","focalID","group","year","scan.number","focal.activity","focal.activity.isPost","partner.ID","in.proximity","num.prox","isProx","isSocial","isSocialGive", "isSocialGet","isAgg", "Q","isPost","timeBlock")
scans2018 <- scans2018[, col_order]
prox_data =  scans2018[,c("focalID","in.proximity")]
}else{ #if not 2018 (i.e. regular focal data)
############################################################################
#Load data
setwd('~/Documents/GitHub/Cayo-Maria-Disease-Modeling/Data/Data All Cleaned/BehavioralDataFiles')
prox_data = read.csv(paste("Group",groupyears[gy],"_ProximityGroups.txt", sep = ""))
meta_data = read.csv(paste("Group",groupyears[gy],"_GroupByYear.txt", sep = "")) #load meta data
#cleaned_data = read.csv(paste("Group",groupyears[gy],"_CleanedData.txt", sep = ""))
#Set NA focal activity in scans to "Rest"
prox_data$focal.activity[is.na(prox_data$focal.activity)]="rest"
if (groupyears[gy]=="HH2016"){
#Add HH dominance for subadults.
hh.dominance <- read.csv("HH_Dominance.csv");names(hh.dominance)[1]="id"
hh.dominance$id = as.character(hh.dominance$id)
hh.dominance$id[hh.dominance$id=="2.00E+09"]="2E9"
hh.dominance$id[hh.dominance$id=="2.00E+08"]="2E8"
hh.dominance$id[hh.dominance$id=="7.00E+00"]="7E0"
hh.dominance$id[hh.dominance$id=="7.00E+03"]="7E3"
hh.dominance$id[hh.dominance$id=="8.00E+02"]="8E2"
meta_data[,c("ordinal.rank","percofsex.dominanted")]=hh.dominance[match(meta_data$id, hh.dominance$id),c("ordinal.rank","percofsex.domianted")]
}
if (groupyears[gy]=="KK2017"){
#Add HH dominance for juveniles.
kk.dominance <- read.csv("KK_dominance_withSubadults.csv");names(kk.dominance)[1]="id"
meta_data[,c("ordinal.rank","percofsex.dominanted")]=kk.dominance[match(meta_data$id, kk.dominance$id),c("ordinal.rank","percofsex.domianted")]
}
if (groupyears[gy] == "V2019"){ #quick fix for now
prox_idx = !is.na(prox_data$partners.activity..sequential.) #find indices where there are individuals in proximity
#add focal monkey in proximity column
prox_data$in.proximity[prox_idx]= paste(prox_data$focal.monkey[prox_idx],
prox_data$in.proximity[prox_idx],sep=",")
}
} #end of year clause (2018 vs. other)
#Format data with aggregate format
# Output the Master Edgelist of all possible pairs given the unique IDs.
unqIDs = meta_data$id#[meta_data$focalcutoff_met=="Y"]
edgelist = calcMasterEL(unqIDs);
df_obs_agg  = calcEdgeList(prox_data, edgelist); ##IMPORTANT NOTE: the structure of the proximity data is different for
#2018 relative to other years (the focal ID is not counted in proximity for 2018 but it is for other years)
#This is not a problem because the focal ID column name is not the same so the function works properly as is.
names(df_obs_agg)=c("ID1", "ID2", "dyad_id","count")
#Get observation effort for each dyad
if (years[gy]==2018){numscans = as.data.frame(table(prox_data$focalID))}else{ numscans = as.data.frame(table(prox_data$focal.monkey))}
df_obs_agg$ID1_obseff_duration = meta_data$hrs.focalfollowed[match(df_obs_agg$ID1, meta_data$id)]
df_obs_agg$ID1_obseff_samples = numscans$Freq[match(df_obs_agg$ID1, numscans$Var1)]
df_obs_agg$ID2_obseff_duration = meta_data$hrs.focalfollowed[match(df_obs_agg$ID2, meta_data$id)]
df_obs_agg$ID2_obseff_samples = numscans$Freq[match(df_obs_agg$ID2, numscans$Var1)]
df_obs_agg$total_obs_time = df_obs_agg$ID1_obseff_duration  + df_obs_agg$ID2_obseff_duration
df_obs_agg$total_samples = df_obs_agg$ID1_obseff_samples + df_obs_agg$ID2_obseff_samples
## Add id qualifiers
#sex
df_obs_agg$ID1_sex = meta_data$sex[match(df_obs_agg$ID1, meta_data$id)]
df_obs_agg$ID2_sex = meta_data$sex[match(df_obs_agg$ID2, meta_data$id)]
#rank
df_obs_agg$ID1_rank = meta_data$ordinal.rank[match(df_obs_agg$ID1, meta_data$id)]
df_obs_agg$ID2_rank = meta_data$ordinal.rank[match(df_obs_agg$ID2, meta_data$id)]
#age
df_obs_agg$ID1_age = meta_data$age[match(df_obs_agg$ID1, meta_data$id)]
df_obs_agg$ID2_age = meta_data$age[match(df_obs_agg$ID2, meta_data$id)]
#group, year, Hurricane status
df_obs_agg$group = group[gy]; df_obs_agg$year = years[gy];
if(years[gy]>2017){df_obs_agg$isPost = "post"}else{df_obs_agg$isPost = "pre"}
head(df_obs_agg)
###################################################################
# Merge and save data
edgelist.all = rbind(edgelist.all, df_obs_agg)
}
# #Check V2019 data is normal
# df = edgelist.all[edgelist.all$group=="V" & edgelist.all$year=="2015",]
# length(which(df$count!=0))/nrow(df)
#extract the number of unique IDs
unique_names <- unique(c(df_obs_agg$ID1, df_obs_agg$ID2))
nr_ind <- length(unique_names)
nr_dyads <- nr_ind*(nr_ind-1)/2 # -1 to remove self-interactions e.g. AA & /2 because undirected so AB = BA
df_obs_agg$ID1 = factor(df_obs_agg$ID1, levels = unique_names); df_obs_agg$ID2 = factor(df_obs_agg$ID2, levels = unique_names);
df_obs_agg$ID1_id = as.integer(df_obs_agg$ID1); df_obs_agg$ID2_id = as.integer(df_obs_agg$ID2)
df_obs_agg$dyad_id = factor(df_obs_agg$dyad_id, levels=df_obs_agg$dyad_id)
setwd("~/Documents/GitHub/Cayo-Maria-Disease-Modeling/Data/R.Data/")
save(edgelist.all,file="proximity_data.RData")
