---
title: "Disease_simu_cayo"
author: "Alba Motes Rodrigo"
date: "07/09/2022"
output: html_document
---

```{r}
library(dplyr)
library(igraph)
library(foreach)
library(doParallel)
n.cores<-parallel::detectCores()-1
#set up local cluster
my.cluster <- parallel::makeCluster(
  n.cores, 
  type = "FORK"
  )
doParallel::registerDoParallel(cl = my.cluster)
```


```{r}
#read data
load("~/Library/Mobile Documents/com~apple~CloudDocs/Cayo-Maria-Disease-Modeling/Data/R.Data/proximity_data.RData")
#create weight variable. Proportion of scans observed in proximity
edgelist.all$weight<- edgelist.all$count/edgelist.all$total_samples
table(edgelist.all$group, edgelist.all$year)#S group is only observed one year and both KK and F are only observed one year after the huricane.
#separate data by group and year
V.data<-subset(edgelist.all, group=="V")
F.data<-subset(edgelist.all, group=="F")
KK.data<-subset(edgelist.all, group=="KK")
```

# V group analyses
```{r}
#number of individuals observed per year
V.data%>%group_by(year)%>%summarise(N=length(unique(unlist(ID1,ID2))))
#create different data frames for each year and combine into one list V.data.list
yearsV<-unique(V.data$year)
V.data.list<-list()
for (i in 1:length(yearsV)){
   V.data.list[[i]]<-subset(V.data, year==yearsV[i])
   names(V.data.list)<-yearsV
}
```

## Simulation seedless and Pt=1
```{r}

list_df=V.data.list
reps=10#number of times the simulation should be repeated
#at each simulation time step, two individuals will interact according their probability of proxomity (edge weight). In each time step, all possible dyads are considered.
sims=1000#number of time steps/times each dyad should be allowed to potentially interact/scans
simu_res = replicate(6, NA, simplify = F)#storing object for simulation results
list_names=yearsV

simu_res<-foreach(d=1:length(list_df))%dopar%{
  #for each year...
        df <- list_df[[d]]
        #calculate group size
        N=length(unique(unlist(df$ID1, df$ID2)))
        #create adjancecy matrix
        mygraph <- graph.data.frame(df)
        my_mat<-get.adjacency(mygraph, sparse = FALSE, attr='weight')
        #next line optional but ensures lower tri is NAs
        my_mat[lower.tri(my_mat)] <- NA
        #empty vectors for simulation results
            value90 <- rep(NA, reps)
            value50 <- rep(NA, reps)
            value60 <- rep(NA, reps)
            value70 <- rep(NA, reps)
            value80 <- rep(NA, reps)
            props <- rep(NA, sims)
            for (r in 1:reps){
            #create vector to store the health status of each individual at each simulation step (sim)
              health=rep(0, N)
            #infect a random individual, change its status to infected in health vector
              health[floor(runif(1, min=1, max=N+1))]=1
              for(s in 1:sims){
            #create new vector where infected individuals ID are stored after each iteraction over the matrix
              health_update=c()
              #iterate over upper triangle matrix
                for(i in 1:(N-1)){
                  for(j in (i+1):N){
                    #if one of the two individuals considered is infected..
                    if(sum(health[i],health[j])==1){
                    #evaluate whether they interact according to edge weight
                     if(runif(n=1)<my_mat[i,j]){
                      #if they interact, infect the healthy individual by adding its id to the updates vector
                      health_update <- append(health_update,c(i,j))
                      }
                    }
                  }
                }
              #change the status of the newly infected individuals in the health status vector
              health_unique<- unique(health_update)
              for (h in health_unique){
                health[h]=1
              }
              #calculate proportion of infected individuals in each simulation step (sims)
              props[s]<- sum(health)/length(health)  
              }
            #write down at which simulation step different thresholds of proportions of individuals infected were reached for each repetition of the simulation (reps)
            value90[r] <- which(props >= 0.9)[1]
            value80[r] <- which(props >= 0.8)[1]
            value70[r] <- which(props >= 0.7)[1]
            value60[r] <- which(props >= 0.6)[1]
            value50[r] <- which(props >= 0.5)[1]
            }
            #store simulation steps at which thresholds were reached in each repetition of the simulation into list
        simu_res[[d]]<- data.frame("time_to_90"=value90, 
                                              "time_to_50"=value50, 
                                              "time_to_80"=value80, 
                                              "time_to_70"=value70, 
                                              "time_to_60"=value60)
    }
#name data frames in list with year names
names(simu_res)<-list_names
parallel::stopCluster(cl = my.cluster)
```

## Simulation seedless, Pi=0.1 and Pdeath=0.112/0.09
Bulfone et al. 2021 Journal of Infections Diseases DOI:10.1093/infdis/jiaa742
Razani et al. 2021 Journal of Infections Diseases https://doi.org/10.1093/infdis/jiab298
Young et al. 2022 The Lancet DOI:https://doi.org/10.1016/S1473-3099(20)30911-7

```{r}
pinf=0.1
simu_res<-foreach(d=1:length(list_df))%dopar%{
  #for each year...
        df <- list_df[[d]]
        #calculate group size
        N=length(unique(unlist(df$ID1, df$ID2)))
        #create adjancecy matrix
        mygraph <- graph.data.frame(df)
        my_mat<-get.adjacency(mygraph, sparse = FALSE, attr='weight')
        #next line optional but ensures lower tri is NAs
        my_mat[lower.tri(my_mat)] <- NA
        #empty vectors for simulation results
            value90 <- rep(NA, reps)
            value50 <- rep(NA, reps)
            value60 <- rep(NA, reps)
            value70 <- rep(NA, reps)
            value80 <- rep(NA, reps)
            props <- rep(NA, sims)
            for (r in 1:reps){
            #create vector to store the health status of each individual at each simulation step (sim)
              health=rep(0, N)
            #infect a random individual, change its status to infected in health vector
              health[floor(runif(1, min=1, max=N+1))]=1
              for(s in 1:sims){
            #create new vector where infected individuals ID are stored after each iteraction over the matrix
              health_update=c()
              #iterate over upper triangle matrix
                for(i in 1:(N-1)){
                  for(j in (i+1):N){
                    #if one of the two individuals considered is infected..
                    if(sum(health[i],health[j])==1){
                    #evaluate whether they interact according to edge weight
                     if(runif(n=1)<my_mat[i,j]){
                      #if they interact, evaluate whether it gets infected. If it does...
                       if(runif(n=1)<pinf){
                         #update its status to infected in the updates' vector
                        health_update <- append(health_update,c(i,j))
                       }
                      }
                    }
                  }
                }
              #change the status of the newly infected individuals in the health status vector
              health_unique<- unique(health_update)
              for (h in health_unique){
                health[h]=1
              }
              #calculate proportion of infected individuals in each simulation step (sims)
              props[s]<- sum(health)/length(health)  
              }
            #write down at which simulation step different thresholds of proportions of individuals infected were reached for each repetition of the simulation (reps)
            value90[r] <- which(props >= 0.9)[1]
            value80[r] <- which(props >= 0.8)[1]
            value70[r] <- which(props >= 0.7)[1]
            value60[r] <- which(props >= 0.6)[1]
            value50[r] <- which(props >= 0.5)[1]
            }
            #store simulation steps at which thresholds were reached in each repetition of the simulation into list
        simu_res[[d]]<- data.frame("time_to_90"=value90, 
                                              "time_to_50"=value50, 
                                              "time_to_80"=value80, 
                                              "time_to_70"=value70, 
                                              "time_to_60"=value60)
    }
#name data frames in list with year names
names(simu_res)<-list_names

```

