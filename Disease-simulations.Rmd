---
title: "Disease_simu_cayo"
author: "Alba Motes Rodrigo"
date: "05/10/2022"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r, warning=FALSE, message=F}
library(dplyr)
library(igraph)
library(foreach)
library(doParallel)
library(stringr)

n.cores<-parallel::detectCores()-1
#set up local cluster
my.cluster <- parallel::makeCluster(
  n.cores, 
  type = "FORK"
  )
doParallel::registerDoParallel(cl = my.cluster)
```


```{r}
#read data
# load("~/Library/Mobile Documents/com~apple~CloudDocs/Cayo-Maria-Disease-Modeling/Data/R.Data/proximity_data.RData")
load("Data/R.Data/proximity_data.RData")
#create weight variable. Proportion of scans observed in proximity
edgelist.all$weight<- edgelist.all$count/edgelist.all$total_samples
table(edgelist.all$group, edgelist.all$year)#S group is only observed one year and both KK and F are only observed one year after the huricane.
#separate data by group and year
V.data<-subset(edgelist.all, group=="V")
F.data<-subset(edgelist.all, group=="F")
KK.data<-subset(edgelist.all, group=="KK")
```

# V group analyses
```{r}
#number of individuals observed per year
V.data%>%group_by(year)%>%summarise(N=length(unique(unlist(ID1,ID2))))
V.data<-subset(V.data, select=c("ID1", "ID2", "weight", "year"))
#create different data frames for each year and combine into one list V.data.list
yearsV<-unique(V.data$year)
V.data.list.raw<-list()
for (i in 1:length(yearsV)){
   V.data.list.raw[[i]]<-subset(V.data, year==yearsV[i])
}
names(V.data.list.raw)<-yearsV
V.data.list.raw<-lapply(V.data.list.raw, function(x) x[!(names(x) %in% c("year"))])
```
Change 0s to 0.0001 because the 0s might be a sampling artifact and it is not realistic the assume that because two monkeys were never observed in proximity they never were.Data sets without 0s are saved as V.data.list. V.data.raw has 0s.
```{r}
V.data.list<-V.data.list.raw
for (i in 1:length(V.data.list)){
  V.data.list[[i]]$weight<-replace(V.data.list[[i]]$weight, V.data.list[[i]]$weight == 0, 0.0001)
}

mins<-rep(NA, 6)
for (i in 1:length(V.data.list)){
  mins[i]<-min(V.data.list[[i]]$weight, na.rm = T)
}
mins
```

## Simulation seedless, Pi=0.1, 0.01 and 0.2
Bulfone et al. 2021 Journal of Infections Diseases DOI:10.1093/infdis/jiaa742
Razani et al. 2021 Journal of Infections Diseases https://doi.org/10.1093/infdis/jiab298
Young et al. 2022 The Lancet DOI:https://doi.org/10.1016/S1473-3099(20)30911-7

```{r}
list_df=V.data.list
reps=5#number of times the simulation should be repeated
#at each simulation time step, two individuals will interact according to their probability of proxomity (edge weight). In each time step, all possible dyads are considered.
sims=10000#number of time steps/times each dyad should be allowed to potentially interact/scans
simu_res = list()#storing object for simulation results
props_res=data.frame(matrix(NA, nrow = sims, ncol = reps))
props_res_list= list()
list_names=yearsV
pinfs=c(0.01, 0.1, 0.2)


simu_res_pinf<-foreach(d=1:length(list_df))%:% foreach(pinf=pinfs)%dopar%{
  #for each year...
        df <- list_df[[d]]
        #create adjancecy matrix
        mygraph <- graph.data.frame(df)
        my_mat<-get.adjacency(mygraph, sparse = FALSE, attr='weight')
        #calculate group size
        N=length(colnames(my_mat))
        #next line optional but ensures lower tri is NAs
        my_mat[lower.tri(my_mat)] <- NA
        #empty vectors for simulation results
            value100 <- rep(NA, reps)
            value90 <- rep(NA, reps)
            value50 <- rep(NA, reps)
            value60 <- rep(NA, reps)
            value70 <- rep(NA, reps)
            value80 <- rep(NA, reps)
            maxprop <- rep(NA, reps)
            props <- rep(NA, sims)
            for (r in 1:reps){
            #create vector to store the health status of each individual at each simulation step (sim)
              health=rep(0, N)
            #infect a random individual, change its status to infected in health vector
              set.seed(1)
              health[floor(runif(1, min=1, max=N+1))]=1
              for(s in 1:sims){
            #create new vector where infected individuals ID are stored after each iteraction over the matrix
              health_update=c()
              #iterate over upper triangle matrix
                for(i in 1:(N-1)){
                  for(j in (i+1):N){
                    #if one of the two individuals considered is infected..
                    if(sum(health[i],health[j])==1){
                    #evaluate whether they interact according to edge weight
                     if(runif(n=1)<my_mat[i,j]){
                      #if they interact, evaluate whether it gets infected. If it does...
                       if(runif(n=1)<pinf){
                         #update its status to infected in the updates' vector
                        health_update <- append(health_update,c(i,j))
                       }
                      }
                    }
                  }
                }
              #change the status of the newly infected individuals in the health status vector
              health_unique<- unique(health_update)
              for (h in health_unique){
                health[h]=1
              }
              #calculate proportion of infected individuals in each simulation step (sims)
              props[s]<- sum(health)/length(health)  
              }
            #write down at which simulation step different thresholds of proportions of individuals infected were reached for each repetition of the simulation (reps)
            value100[r] <- which(props == 1)[1]
            value90[r] <- which(props >= 0.9)[1]
            value80[r] <- which(props >= 0.8)[1]
            value70[r] <- which(props >= 0.7)[1]
            value60[r] <- which(props >= 0.6)[1]
            value50[r] <- which(props >= 0.5)[1]
            maxprop[r] <- max(props)
           #store proportion of infected individuals at each simulation step for each repetition of the simulation (reps) 
            props_res[, r]<-props
            }
            #store simulation steps at which thresholds were reached in each repetition of the simulation into list
        simu_res[[d]]<- list(data.frame("time_to_100"=value100,
                                   "time_to_90"=value90, 
                                    "time_to_50"=value50, 
                                    "time_to_80"=value80, 
                                    "time_to_70"=value70, 
                                    "time_to_60"=value60,
                                    "max_infected"=maxprop), props_res) 
        
    }
#name data frames in list with year names
names(simu_res_pinf)<-list_names

for (i in 1:6){
  names(simu_res_pinf[[i]]) <- pinfs
}
```

#Run 1 rep of the simulation to obtain IDs for plotting
```{r}
list_df=V.data.list
list_names=yearsV
pinfs=c(0.01, 0.1, 0.2)
simu_res=list()
sims=10000
simu_res_ids<-foreach(d=1:length(list_df))%:% foreach(pinf=pinfs)%dopar%{
  #for each year...
        df <- list_df[[d]]
        #create adjancecy matrix
        mygraph <- igraph::graph.data.frame(df)
        my_mat<-igraph::get.adjacency(mygraph, sparse = FALSE, attr='weight')
        N=length(colnames(my_mat))
        #next line optional but ensures lower tri is NAs
        my_mat[lower.tri(my_mat)] <- NA
        #empty vectors for simulation results
            #create vector to store the health status of each individual at each simulation step (sim)
        inf_ids_df=data.frame(matrix(NA, nrow = N, ncol = sims))
              health=rep(0, N)
            #infect a random individual, change its status to infected in health vector
              set.seed(1)
              health[floor(runif(1, min=1, max=N+1))]=1
              for(s in 1:sims){
            #create new vector where infected individuals ID are stored after each iteraction over the matrix
              health_update=c()
              #iterate over upper triangle matrix
                for(i in 1:(N-1)){
                  for(j in (i+1):N){
                    #if one of the two individuals considered is infected..
                    if(sum(health[i],health[j])==1){
                    #evaluate whether they interact according to edge weight
                     if(runif(n=1)<my_mat[i,j]){
                      #if they interact, evaluate whether it gets infected. If it does...
                       if(runif(n=1)<pinfs){
                         #update its status to infected in the updates' vector
                        health_update <- append(health_update,c(i,j))
                       }
                      }
                    }
                  }
                }
              #change the status of the newly infected individuals in the health status vector
              health_unique<- unique(health_update)
              for (h in health_unique){
                health[h]=1
              }
              inf_ids_df[, s]<-health
              }
            #store simulation steps at which thresholds were reached in each repetition of the simulation into list
        #inf_ids_df$ids<- colnames(my_mat)
        simu_res[d]<- inf_ids_df
        
}
#name data frames in list with year names
names(simu_res_ids)<-list_names
for (i in 1:6){
  names(simu_res_ids[[i]]) <- pinfs
}


#extract vectors of ids for individual present each year
ids_year=list()
for (d in 1:length(list_df)){
  df <- list_df[[d]]
  #create adjancecy matrix
  mygraph <- igraph::graph.data.frame(df)
  my_mat<-igraph::get.adjacency(mygraph, sparse = FALSE, attr='weight')
  ids_year[[d]]=colnames(my_mat)
}

#paste in each health_status data frame (simu_res_ids) the ids of the individuals present in that year
for (i in 1:length(simu_res_ids)){
  for (j in 1:length(simu_res_ids[[i]])){
   x=simu_res_ids[[i]][[j]]
  x=cbind(x, ids=ids_year[[i]])
  simu_res_ids[[i]][[j]]=x
  }
}
```
 

#Calculate network properties for each year
Modularity, Clustering, Density
```{r}
network_char<- data.frame(densities=c(), modularity_fg=c(), betweenness()) 
list_df<-V.data.list.raw

for(d in 1:length(list_df)){
    df <- list_df[[d]]
      #create adjancency matrix from edgelist
    mygraph <- igraph::graph_from_data_frame(df, directed=F)#create graph from data frame
    #density
    density_res<-sum(df$weight>0)/nrow(df)
    network_char[d, "densities"]=density_res
    #clustering
    modularity_res_fg<-cluster_fast_greedy(mygraph, modularity = T, membership = T)
    modularity_res_fg<-max(modularity_res_fg$modularity)
    network_char[d, "modularity_fg"]=modularity_res_fg
    network_char[d, "year"]=names(list_df[d])
}
```


#Calculate individuals' betweenes to seed simulations
```{r}
list_df<-V.data.list
betweenness_data=list()
seeds_betweenness=list()
for(d in 1:length(list_df)){
    df <- list_df[[d]]
      #create adjancency matrix from edgelist
    mygraph <- igraph::graph_from_data_frame(df, directed=F)#create graph from data frame
    betweenness_data[[d]]<-betweenness(mygraph, directed = F,v = V(mygraph), normalized = FALSE)
    seeds_betweenness[[d]]<-subset(betweenness_data[[d]],betweenness_data[[d]] < quantile(betweenness_data[[d]], 0.1))
}
names(betweenness_data)<-list_names
names(seeds_betweenness)<-list_names
```

## Simulation seeded, Pi=0.1, 0.01 and 0.2
```{r}
list_df=V.data.list
reps=5#number of times the simulation should be repeated
#at each simulation time step, two individuals will interact according to their probability of proxomity (edge weight). In each time step, all possible dyads are considered.
sims=1000#number of time steps/times each dyad should be allowed to potentially interact/scans
simu_res = list()#storing object for simulation results
props_res=data.frame(matrix(NA, nrow = sims, ncol = reps))
props_res_list= list()
list_names=yearsV
pinfs=c(0.01, 0.1, 0.2)


simu_seeded_res_pinf<-foreach(d=1:length(list_df)) %:% foreach(pinf=pinfs)%dopar%{
  #for each year...
        df <- list_df[[d]]
        #create adjancecy matrix
        mygraph <- graph.data.frame(df)
        my_mat<-get.adjacency(mygraph, sparse = FALSE, attr='weight')
        #calculate group size
        N=length(colnames(my_mat))
        #next line optional but ensures lower tri is NAs
        my_mat[lower.tri(my_mat)] <- NA
        #empty vectors for simulation results
            value100 <- rep(NA, reps)
            value90 <- rep(NA, reps)
            value50 <- rep(NA, reps)
            value60 <- rep(NA, reps)
            value70 <- rep(NA, reps)
            value80 <- rep(NA, reps)
            maxprop <- rep(NA, reps)
            props <- rep(NA, sims)
            for (r in 1:reps){
            #create vector to store the health status of each individual at each simulation step (sim)
              health=rep(0, N)
              names(health)<-names(betweenness_data[[d]])
            #infect a random individual, change its status to infected in health vector
              set.seed(1)
              health[names(sample(seeds_betweenness[[d]], size=1))]=1
              for(s in 1:sims){
            #create new vector where infected individuals ID are stored after each iteraction over the matrix
              health_update=c()
              #iterate over upper triangle matrix
                for(i in 1:(N-1)){
                  for(j in (i+1):N){
                    #if one of the two individuals considered is infected..
                    if(sum(health[i],health[j])==1){
                    #evaluate whether they interact according to edge weight
                     if(runif(n=1)<my_mat[i,j]){
                      #if they interact, evaluate whether it gets infected. If it does...
                       if(runif(n=1)<pinf){
                         #update its status to infected in the updates' vector
                        health_update <- append(health_update,c(i,j))
                       }
                      }
                    }
                  }
                }
              #change the status of the newly infected individuals in the health status vector
              health_unique<- unique(health_update)
              for (h in health_unique){
                health[h]=1
              }
              #calculate proportion of infected individuals in each simulation step (sims)
              props[s]<- sum(health)/length(health)  
              }
            #write down at which simulation step different thresholds of proportions of individuals infected were reached for each repetition of the simulation (reps)
            value100[r] <- which(props == 1)[1]
            value90[r] <- which(props >= 0.9)[1]
            value80[r] <- which(props >= 0.8)[1]
            value70[r] <- which(props >= 0.7)[1]
            value60[r] <- which(props >= 0.6)[1]
            value50[r] <- which(props >= 0.5)[1]
            maxprop[r] <- max(props)
           #store proportion of infected individuals at each simulation step for each repetition of the simulation (reps) 
            props_res[, r]<-props
            }
            #store simulation steps at which thresholds were reached in each repetition of the simulation into list
        simu_res[[d]]<- list(data.frame("time_to_100"=value100,
                                   "time_to_90"=value90, 
                                    "time_to_50"=value50, 
                                    "time_to_80"=value80, 
                                    "time_to_70"=value70, 
                                    "time_to_60"=value60,
                                    "max_infected"=maxprop), props_res) 
        
    }
#name data frames in list with year names
names(simu_seeded_res_pinf)<-list_names

for (i in 1:6){
  names(simu_seeded_res_pinf[[i]]) <- pinfs
}
```


I was getting an error of invalid connection and running this chunked fixed it
```{r}
unregister_dopar <- function() {
  env <- foreach:::.foreachGlobals
  rm(list=ls(name=env), pos=env)
}
#unregister_dopar()
```

```{r}
save.image(file="/Users/alba/Library/Mobile Documents/com~apple~CloudDocs/Cayo-Maria-Disease-Modeling/macaque_disease_simulation.RData")
```
