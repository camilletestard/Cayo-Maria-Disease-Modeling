---
title: "Disease_simu_cayo"
author: "Alba Motes Rodrigo"
date: "07/09/2022"
output: html_document
editor_options: 
  chunk_output_type: inline
---
chapf

```{r}
library(dplyr)
library(igraph)
library(foreach)
library(doParallel)
library(stringr)

n.cores<-parallel::detectCores()-3
#set up local cluster
my.cluster <- parallel::makeCluster(
  n.cores, 
  type = "FORK"
  )
doParallel::registerDoParallel(cl = my.cluster)
```


```{r}
#read data
# load("~/Library/Mobile Documents/com~apple~CloudDocs/Cayo-Maria-Disease-Modeling/Data/R.Data/proximity_data.RData")
load("Data/R.Data/proximity_data.RData")
#create weight variable. Proportion of scans observed in proximity
edgelist.all$weight<- edgelist.all$count/edgelist.all$total_samples
table(edgelist.all$group, edgelist.all$year)#S group is only observed one year and both KK and F are only observed one year after the huricane.
#separate data by group and year
V.data<-subset(edgelist.all, group=="V")
F.data<-subset(edgelist.all, group=="F")
KK.data<-subset(edgelist.all, group=="KK")
```

# V group analyses
```{r}
#number of individuals observed per year
V.data%>%group_by(year)%>%summarise(N=length(unique(unlist(ID1,ID2))))
V.data<-subset(V.data, select=c("ID1", "ID2", "weight", "year"))
#create different data frames for each year and combine into one list V.data.list
yearsV<-unique(V.data$year)
V.data.list<-list()
for (i in 1:length(yearsV)){
   V.data.list[[i]]<-subset(V.data, year==yearsV[i])
}
names(V.data.list)<-yearsV
V.data.list<-lapply(V.data.list, function(x) x[!(names(x) %in% c("year"))])
```
Change 0s to 0.0001 because the 0s might be a sampling artifact and it is not realistic the assume that because two monkeys were never observed in proximity they never were.
```{r}
for (i in 1:length(V.data.list)){
  V.data.list[[i]]$weight<-replace(V.data.list[[i]]$weight, V.data.list[[i]]$weight == 0, 0.0001)
}

mins<-rep(NA, 6)
for (i in 1:length(V.data.list)){
  mins[i]<-min(V.data.list[[i]]$weight, na.rm = T)
}
mins
```

## Simulation seedless, Pi=0.1, 0.01 and 0.2
Bulfone et al. 2021 Journal of Infections Diseases DOI:10.1093/infdis/jiaa742
Razani et al. 2021 Journal of Infections Diseases https://doi.org/10.1093/infdis/jiab298
Young et al. 2022 The Lancet DOI:https://doi.org/10.1016/S1473-3099(20)30911-7

```{r}
list_df=V.data.list
reps=10#number of times the simulation should be repeated
#at each simulation time step, two individuals will interact according to their probability of proximity (edge weight). In each time step, all possible dyads are considered.
sims=1000#number of time steps/times each dyad should be allowed to potentially interact/scans
simu_res = list()#storing object for simulation results
props_res=data.frame(matrix(NA, nrow = sims, ncol = reps))
props_res_list= list()
list_names=yearsV
pinfs=c(0.01, 0.1, 0.2)


simu_res_pinf<-foreach(d=1:length(list_df))%:% foreach(pinf=pinfs)%dopar%{
  #for each year...
        df <- list_df[[d]]
        #calculate group size
        N=length(unique(unlist(df$ID1, df$ID2)))
        #create adjancecy matrix
        mygraph <- graph.data.frame(df)
        my_mat<-get.adjacency(mygraph, sparse = FALSE, attr='weight')
        #next line optional but ensures lower tri is NAs
        my_mat[lower.tri(my_mat)] <- NA
        #empty vectors for simulation results
            value100 <- rep(NA, reps)
            value90 <- rep(NA, reps)
            value50 <- rep(NA, reps)
            value60 <- rep(NA, reps)
            value70 <- rep(NA, reps)
            value80 <- rep(NA, reps)
            maxprop <- rep(NA, reps)
            props <- rep(NA, sims)
            for (r in 1:reps){
            #create vector to store the health status of each individual at each simulation step (sim)
              health=rep(0, N)
            #infect a random individual, change its status to infected in health vector
              health[floor(runif(1, min=1, max=N+1))]=1
              for(s in 1:sims){
            #create new vector where infected individuals ID are stored after each iteraction over the matrix
              health_update=c()
              #iterate over upper triangle matrix
                for(i in 1:(N-1)){
                  for(j in (i+1):N){
                    #if one of the two individuals considered is infected..
                    if(sum(health[i],health[j])==1){
                    #evaluate whether they interact according to edge weight
                     if(runif(n=1)<my_mat[i,j]){
                      #if they interact, evaluate whether it gets infected. If it does...
                       if(runif(n=1)<pinf){
                         #update its status to infected in the updates' vector
                        health_update <- append(health_update,c(i,j))
                       }
                      }
                    }
                  }
                }
              #change the status of the newly infected individuals in the health status vector
              health_unique<- unique(health_update)
              for (h in health_unique){
                health[h]=1
              }
              #calculate proportion of infected individuals in each simulation step (sims)
              props[s]<- sum(health)/length(health)  
              }
            #write down at which simulation step different thresholds of proportions of individuals infected were reached for each repetition of the simulation (reps)
            value100[r] <- which(props == 1)[1]
            value90[r] <- which(props >= 0.9)[1]
            value80[r] <- which(props >= 0.8)[1]
            value70[r] <- which(props >= 0.7)[1]
            value60[r] <- which(props >= 0.6)[1]
            value50[r] <- which(props >= 0.5)[1]
            maxprop[r] <- max(props)
           #store proportion of infected individuals at each simulation step for each repetition of the simulation (reps) 
            props_res[, r]<-props
            }
            #store simulation steps at which thresholds were reached in each repetition of the simulation into list
        simu_res[[d]]<- list(data.frame("time_to_100"=value100,
                                   "time_to_90"=value90, 
                                    "time_to_50"=value50, 
                                    "time_to_80"=value80, 
                                    "time_to_70"=value70, 
                                    "time_to_60"=value60,
                                    "max_infected"=maxprop), props_res) 
        
    }
#name data frames in list with year names
names(simu_res_pinf)<-list_names

for (i in 1:6){
  names(simu_res_pinf[[i]]) <- pinfs
}
```

#Run 1 rep of the simulation to obtain IDs for plotting
```{r}
list_df=V.data.list
list_names=yearsV
pinfs=0.1 #c(0.01, 0.1, 0.2)
simu_res=list()
sims=1000
simu_res_ids<-foreach(d=1:length(list_df))%:% foreach(pinf=pinfs)%dopar%{
  #for each year...
        df <- list_df[[d]]
        #create adjancecy matrix
        mygraph <- igraph::graph.data.frame(df)
        my_mat<-igraph::get.adjacency(mygraph, sparse = FALSE, attr='weight')
        N=length(colnames(my_mat))
        #next line optional but ensures lower tri is NAs
        my_mat[lower.tri(my_mat)] <- NA
        #empty vectors for simulation results
            #create vector to store the health status of each individual at each simulation step (sim)
        inf_ids_df=data.frame(matrix(NA, nrow = N, ncol = sims))
              health=rep(0, N)
            #infect a random individual, change its status to infected in health vector
              health[floor(runif(1, min=1, max=N+1))]=1
              for(s in 1:sims){
            #create new vector where infected individuals ID are stored after each iteraction over the matrix
              health_update=c()
              #iterate over upper triangle matrix
                for(i in 1:(N-1)){
                  for(j in (i+1):N){
                    #if one of the two individuals considered is infected..
                    if(sum(health[i],health[j])==1){
                    #evaluate whether they interact according to edge weight
                     if(runif(n=1)<my_mat[i,j]){
                      #if they interact, evaluate whether it gets infected. If it does...
                       if(runif(n=1)<pinfs){
                         #update its status to infected in the updates' vector
                        health_update <- append(health_update,c(i,j))
                       }
                      }
                    }
                  }
                }
              #change the status of the newly infected individuals in the health status vector
              health_unique<- unique(health_update)
              for (h in health_unique){
                health[h]=1
              }
              inf_ids_df[, s]<-health
              }
            #store simulation steps at which thresholds were reached in each repetition of the simulation into list
        #inf_ids_df$ids<- colnames(my_mat)
        simu_res[d]<- inf_ids_df
        
}
#name data frames in list with year names
names(simu_res_ids)<-list_names
for (i in 1:6){
  names(simu_res_ids[[i]]) <- pinfs
}


#extract vectors of ids for individual present each year
ids_year=list()
for (d in 1:length(list_df)){
  df <- list_df[[d]]
  #create adjancecy matrix
  mygraph <- igraph::graph.data.frame(df)
  my_mat<-igraph::get.adjacency(mygraph, sparse = FALSE, attr='weight')
  ids_year[[d]]=colnames(my_mat)
}

#paste in each health_status data frame (simu_res_ids) the ids of the individuals present in that year
for (i in 1:length(simu_res_ids)){
  for (j in 1:length(simu_res_ids[[i]])){
   x=simu_res_ids[[i]][[j]]
  x=cbind(x, ids=ids_year[[i]])
  simu_res_ids[[i]][[j]]=x
  }
}
```
 

#Network simulations to calculate network properties
```{r}

network_sims<-foreach(d=1:length(list_df))%dopar%{
   df <- list_df[[1]]
   for (s in 1:sims){
     new.vec=c()
     for(i in 1:nrow(df)){
          new.vec[i]<-ifelse(runif(n=1)<df[3,"weight"], 1, 0)
     }
   df<-cbind(df, new.vec)
   
            
   
```


#Calculate network properties for each year
Modularity, Clustering, Density
```{r}
network_char<- data.frame( diameter= c(),densities=c(), clustering=c()) 

for(d in 1:length(list_df)){
    df <- list_df[[1]]
      #create adjancency matrix from edgelist
    mygraph <- igraph::graph.data.frame(df, directed=F)#create graph from data frame
    #diameter
    diameter_res<- igraph::diameter(mygraph,  unconnected = F, weights = df$weight)
    network_char[d, "diameter"]=diameter_res
    #efficiency
    #efficiency_res<-igraph::global_efficiency(mygraph, weights = df$weight, directed = F)
    #network_char[d, "efficiency"]=efficiency_res#normalized
    #density
    density_res<-igraph::edge_density(mygraph, loops = F)
    network_char[d, "densities"]=density_res
    #clustering
    clustering_coeffs<-mean(igraph::transitivity(mygraph, type="weighted"))
    network_char[d, "clustering"]=clustering_coeffs
    network_char[d, "year"]=names(list_df[d])
}
```




I was getting an error of invalid connection and running this chunked fixed it
```{r}
unregister_dopar <- function() {
  env <- foreach:::.foreachGlobals
  rm(list=ls(name=env), pos=env)
}
#unregister_dopar()
```

#Plot simulations V group
Each line is a simulation. Bold lines are the means per years. Dashed lines are after the hurricane.
```{r}
par(mfrow=c(1,6))
for(i in 1:length(simu_res_pinf)){
  hist(simu_res_pinf[[i]]$time_to_50, col=c("chocolate3"), breaks=20, ylim=c(0,5), xlim=c(0, 3000), xaxt="n", xlab=names(simu_res_pinf)[i], ylab="", main="",cex.axis=1)
  axis(1, at = seq(0, 3000, by = 500), las=2, cex.axis=1)
  clip(0,10, 0, 5)
  abline(v=mean(simu_res_pinf[[i]]$time_to_50, na.rm=T), col="orange", lty=1, lwd=3)
  abline(v=median(simu_res_pinf[[i]]$time_to_50, na.rm=T), col="red", lty=3, lwd=3)
}
```

```{r}
pinf_data<-do.call(rbind, simu_res_pinf)#complete data sets from each simulation
pinf_data<- tibble::rownames_to_column(pinf_data)
pinf_data[c('year', 'rep')] <- str_split_fixed(pinf_data$rowname, pattern='.', n=2)
```


# Plots results of simulation per year
```{r}
ydata_sub90 <- subset(all_data, metric=="90")
ydata_sub50 <- subset(all_data, metric=="50")

cols90 <- c("mean", "sd", "skew")

par(mfrow=c(2,3), mar=c(4,4,2,2), cex=1.25)
for (i in cols90){
  stripchart(ydata_sub90[,i]~ydata_sub90$sp, pch=19, col=colours[as.numeric(ydata_sub90$col)], method="jitter", jitter=0.1, ylab="Species", xlab=paste(i, "simulation cycles\n\ until 90% infected", sep=" "))
}

for (i in cols90){
  stripchart(ydata_sub50[,i]~ydata_sub50$sp, pch=19, col=colours[as.numeric(ydata_sub90$col)], method="jitter", jitter=0.1, ylab="Species", xlab=paste(i, "simulation cycles\n\ until 50% infected", sep=" "))
}
```



```{r}
save.image(file="/Users/alba/Library/Mobile Documents/com~apple~CloudDocs/Cayo-Maria-Disease-Modeling/macaque_disease_simulation.RData")
```


and Pdeath=0.112/0.09
