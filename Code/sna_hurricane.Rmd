---
title: "sna_hurricane"
author: "Alba Motes Rodrigo"
date: "2023-11-22"
output: html_document
---
#load packages and data
```{r}
#packages
library(igraph);library(dplyr);library(ggplot2);library(foreach); library(doParallel); library(stringr); library(tidyverse);library(magrittr); library(fs)

#data
load("/Users/alba/Desktop/Postdoc_UNIL/Hurricane_project/BisonFittedNetworks.RData")
load("/Users/alba/Desktop/Postdoc_UNIL/Hurricane_project/proximity_data-2.RData")
```
Remember that all networks are fully connected so modularity and clustering cannot be calculated as they are based on edge densities.

```{r}
#create storage object for densities
obs_dens<-matrix(,ncol=1, nrow = length(unique(edgelist.all$groupyear)))
row.names(obs_dens)<-unique(edgelist.all$groupyear)
colnames(obs_dens)<-c("density")

#create groupyear combination variable
edgelist.all$groupyear<-paste(edgelist.all$group, edgelist.all$year, sep="")
#calculate observed network densities
for (g in unique(edgelist.all$groupyear)){
  z<-subset(edgelist.all, groupyear==g, select = c("ID1", "ID2", "count"))
  z<-z[z$count!= 0,]
  w<-graph_from_data_frame(z[,c(1,2)], directed = F, vertices = NULL)
  E(w)$weight <- z[,3]
  obs_dens[g,1]<-edge_density(w)}

# Setting the threshold at a given density and filtering edges with very small observation prob
posterior.filtered<-vector(mode = "list", length=length(unique(edgelist.all$groupyear)))
names(posterior.filtered)<-unique(edgelist.all$groupyear)

for(s in unique(edgelist.all$groupyear)){#for each groupyear combination

DesiredDensity <- obs_dens[s,1]#extract observed density
#find the threshold needed to assign 0s
FindThreshold <- function(Connections){
  
  Ranks <- rank(Connections)/max(rank(Connections)) # Identifies the numerical order of the values
  
  Connections[Ranks < (1-DesiredDensity)] <- 0 # Assigns the bottom 80% as 0 (according to the density desired)
  
  Connections %>% return # Returns
  
}
#set to 0 all edges with a value below threshold
posterior.filtered[[s]]<-posterior.el[[s]][,3:1002] %>% 
  map(FindThreshold) %>%  # Does this across all draws in the data frame
  bind_cols() %>% 
  bind_cols(posterior.el[[s]][,1:2], .) }
```

```{r}
#create storage object with one value per network
modul_networks<-matrix(, ncol = length(names(posterior.el)), nrow = 1000)
colnames(modul_networks)<-names(posterior.el)

dense_networks<-matrix(, ncol = length(names(posterior.el)), nrow = 1000)
colnames(dense_networks)<-names(posterior.el)

trans_networks<-matrix(, ncol = length(names(posterior.el)), nrow = 1000)
colnames(trans_networks)<-names(posterior.el)

#calculate metrics for each network
for (g in 1:length(names(posterior.filtered))){
  for (d in 3:1002){
    #create each graph
    x<-graph_from_data_frame(posterior.filtered[[g]][,c(1,2)], directed = F, vertices = NULL)
    E(x)$weight <- posterior.filtered[[g]][,d]
    #calculate modularity
    #Greedy optimization for community assignment
    cfg<-cluster_fast_greedy(x, modularity = T, membership = T, weights = posterior.filtered[[g]][,d])
    modul_networks[d-2,g] <-modularity(cfg)
    #substract 0 edges
    y<-delete.edges(x,E(x)[E(x)$weight == 0])
    dense_networks[d-2,g]<- edge_density(y)
    trans_networks[d-2,g]<-transitivity(y, type="global")
  }
}

```

```{r}
#model transitivity before after

#model modularity before after
```


```{r}
rm(posterior.el, edgelist.all, w,x,y,z, cfg, posterior.filtered)
save.image(file='/Users/alba/Desktop/Postdoc_UNIL/Hurricane_project/network_metrics_pre_post.RData')
```

